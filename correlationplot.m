function correlationplot(X1, Y1,varargin)
%correlationplot(x1,y1,color_vec,onetoone)
%  X1:  scatter x
%  Y1:  scatter y
% below arguments are optional, defaults are specified below
%  color_vec:  color for points, must be same length as X and Y, defaults to 0
%  onetoone:  set to 1 for just ODR, 2 for ODR and 1:1 line, defaults to 1
%
%  Auto-generated by MATLAB on 22-Nov-2011 15:40:38
% Modified to do ODR fitting and spit out key fit statistics on plot by pkp
% onetoone is set to 0,1 or 2, 0, plots no fit line, one plots just the ODR line, 2 plots ODR as
% well as a 1:1 line


% Parse optional arguments
if ~isempty(varargin)
    Color_Vector = varargin{1};

else
   Color_Vector = X1*0;
end
if length(varargin) > 1
    onetoone = varargin{2};

else
   onetoone=1;
end

% Create figure
figure1 = figure;

% Create axes
axes1 = axes('Parent',figure1);

hold(axes1,'all');

% Create scatter
scatter1 = scatter(X1,Y1,20,Color_Vector,'filled', 'Parent',axes1,...
    'DisplayName','');
set(get(get(scatter1,'Annotation'),'LegendInformation'),...
    'IconDisplayStyle','off'); % Exclude line from legend



% Get xdata from plot
xdata1 = get(scatter1, 'xdata');
% Get ydata from plot
ydata1 = get(scatter1, 'ydata');
% Make sure data are column vectors
xdata1 = xdata1(:);
ydata1 = ydata1(:);

% Remove NaN values and warn
nanMask1 = isnan(xdata1(:)) | isnan(ydata1(:));
if any(nanMask1)
    warning('GenerateMFile:IgnoringNaNs', ...
        'Data points with NaN coordinates will be ignored.');
    xdata1(nanMask1) = [];
    ydata1(nanMask1) = [];
end

% Find x values for plotting the fit based on xlim
axesLimits1 = xlim(axes1);
xplot1 = linspace(axesLimits1(1), axesLimits1(2));

% Preallocate for "Show equations" coefficients
coeffs1 = cell(1,1);

% Find coefficients for polynomial (order = 1)
%ODR Fitting
%fitResults = linortfit2(xdata1, ydata1)
% Force zero intercept with regular liner fit
%fitResults = polyfitZero(xdata1, ydata1,1)
% Regular Linear Fit
fitResults = polyfit(xdata1, ydata1,1);
% Evaluate polynomial
%yplot1 = fitResults(1)*xplot1+fitResults(2);

yplot1 =polyval(fitResults,xplot1);
yest1 =polyval(fitResults,xdata1);
%yest1=fitResults(1)*xdata1+fitResults(2);
%C = corrcoef([xdata1,ydata1])
[R,P]=corrcoef(xdata1,ydata1)
P(1,2)

R2=R(1,2)^2;
rms=rmse(ydata1,yest1)
[N, ~]=size(xdata1);
% Save type of fit for "Show equations"
%fittypesArray1(1) = 2;

% Save coefficients for "Show Equation"
coeffs1{1} = fitResults;
coeffs1{1} = floor(coeffs1{1}*100)/100;

%Plot the fit
if onetoone~=0
fitLine1 = plot(xplot1,yplot1,'DisplayName','Linear Fit','Parent',axes1,...
    'Tag','Linear Fit',...
    'Color',[1 0 0],'LineWidth',2);
if onetoone==2
fitLine2 = plot(xplot1,xplot1,'DisplayName','1:1','Parent',axes1,...
   'Tag','ODR Fit',...
   'Color',[0 0 0],'LineWidth',2);
end

%Set new line in proper position
setLineOrder(axes1, fitLine1, scatter1);
end
%"Show equations" was selected
showEquations(2, coeffs1, 4, axes1,R2,rms,R(1,2),N);

%Create legend
legend(axes1,'show','Location','NorthEast');
legend('boxoff')

%-------------------------------------------------------------------------%
function setLineOrder(axesh1, newLine1, associatedLine1)
%SETLINEORDER(AXESH1,NEWLINE1,ASSOCIATEDLINE1)
%  Set line order
%  AXESH1:  axes
%  NEWLINE1:  new line
%  ASSOCIATEDLINE1:  associated line

% Get the axes children
hChildren = get(axesh1,'Children');
% Remove the new line
hChildren(hChildren==newLine1) = [];
% Get the index to the associatedLine
lineIndex = find(hChildren==associatedLine1);
% Reorder lines so the new line appears with associated data
hNewChildren = [hChildren(1:lineIndex-1);newLine1;hChildren(lineIndex:end)];
% Set the children:
set(axesh1,'Children',hNewChildren);

%-------------------------------------------------------------------------%
function showEquations(fittypes1, coeffs1, digits1, axesh1,R2,rms,R,N)
%SHOWEQUATIONS(FITTYPES1,COEFFS1,DIGITS1,AXESH1)
%  Show equations
%  FITTYPES1:  types of fits
%  COEFFS1:  coefficients
%  DIGITS1:  number of significant digits
%  AXESH1:  axes

n = length(fittypes1);
txt = cell(length(n + 1) ,1);
txt{1,:} = ' ';
for i = 1:n
    txt{i + 1,:} = getEquationString(fittypes1(i),coeffs1{i},digits1,axesh1);
end
 text(.1,.9,txt,'parent',axesh1, ...
     'verticalalignment','bottom','units','normalized','FontSize',12);

R=num2str(R,'%1.2f');
R2=num2str(R2,2);
rms=num2str(rms,2);
rms= ['Fit RMS=' rms];
R2= ['R^2=' R2];
R= ['R=' R];
N= ['N=' num2str(N)];

%text(.1,.90,R2,'parent',axesh1, ...
%     'verticalalignment','top','units','normalized','FontSize',12);
text(.1,.9,R,'parent',axesh1, ...
    'verticalalignment','top','units','normalized','FontSize',12);
text(.1,.85,N,'parent',axesh1, ...
    'verticalalignment','top','units','normalized','FontSize',12);

%-------------------------------------------------------------------------%
function [s1] = getEquationString(fittype1, coeffs1, digits1, axesh1)
%GETEQUATIONSTRING(FITTYPE1,COEFFS1,DIGITS1,AXESH1)
%  Get show equation string
%  FITTYPE1:  type of fit
%  COEFFS1:  coefficients
%  DIGITS1:  number of significant digits
%  AXESH1:  axes

if isequal(fittype1, 0)
    s1 = 'Cubic spline interpolant';
elseif isequal(fittype1, 1)
    s1 = 'Shape-preserving interpolant';
else
    op = '+-';
    format1 = ['%s %0.',num2str(digits1,2),'g*x^{%s} %s'];
    format2 = ['%s %0.',num2str(digits1,2),'g'];
    xl = get(axesh1, 'xlim');
    fit =  fittype1 - 1;
    s1 = sprintf('y =');
    th = text(xl*[.95;.05],1,s1,'parent',axesh1, 'vis','off');
    if abs(coeffs1(1) < 0)
        s1 = [s1 ' -'];
    end
    for i = 1:fit
        sl = length(s1);
        if ~isequal(coeffs1(i),0) % if exactly zero, skip it
            s1 = sprintf(format1,s1,abs(coeffs1(i)),num2str(fit+1-i,2), op((coeffs1(i+1)<0)+1));
        end
        if (i==fit) && ~isequal(coeffs1(i),0)
            s1(end-5:end-2) = []; % change x^1 to x.
        end
        set(th,'string',s1);
        et = get(th,'extent');
        if et(1)+et(3) > xl(2)
            s1 = [s1(1:sl) sprintf('\n     ') s1(sl+1:end)];
        end
    end
    if ~isequal(coeffs1(fit+1),0)
        sl = length(s1);
        s1 = sprintf(format2,s1,abs(coeffs1(fit+1)));
        set(th,'string',s1);
        et = get(th,'extent');
        if et(1)+et(3) > xl(2)
            s1 = [s1(1:sl) sprintf('\n     ') s1(sl+1:end)];
        end
    end
    delete(th);
    % Delete last "+"
    if isequal(s1(end),'+')
        s1(end-1:end) = []; % There is always a space before the +.
    end
    if length(s1) == 3
        s1 = sprintf(format2,s1,0);
    end
end

